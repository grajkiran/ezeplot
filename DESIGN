Refactor the code.
Plot elements:
	Quiver
	Nullclines/isoclines
	Trajectories -> static or animated
	Start points -> markers, arrows, both
	Fixed points, limit cycles, closed orbits, index theory, 3D, etc.

One arrow on the static trajectory a little ahead of the point of start.

Update param class:
label, entry_field, spinbox
entry_field: list of values. extract min, max, delta (minimum difference between any two entered values)
scale/spinbox: min, max, resolution = delta

When a point is picked, compute the trajectories for all values of the active parameter and the current values of the remaining parameters and store in db.
traj_db[params] = [trajectories]

Three aspects of the code:
1. The dynamical system
   * Computing trajectories, fixed points, limit cycles, orbit detection, etc.
2. The GUI elements
   * Setting parameters of the dynamic system, plot controls, start stop animation, etc.
3. The plotting functionality
   * Maintaining the figure window, updating plots, etc.

Two figure windows:
1. x-y phase plane + optionally the 3 temporal variations
2. 3D projection showing the complete orbits.

Dynamic trajectory visualization mode. Start point follows mouse around:

Picking a point in 3D: Start at z = 0. get xy from location.
Then move mouse to change the z-coordinate up or down.
